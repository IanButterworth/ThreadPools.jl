<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>ThreadPools.jl · ThreadPool Documentation</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">ThreadPool Documentation</span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>ThreadPools.jl</a><ul class="internal"><li><a class="tocitem" href="#Overview"><span>Overview</span></a></li><li><a class="tocitem" href="#Usage"><span>Usage</span></a></li><li><a class="tocitem" href="#Logger-Usage"><span>Logger Usage</span></a></li><li><a class="tocitem" href="#Simple-API"><span>Simple API</span></a></li><li><a class="tocitem" href="#Composable-API"><span>Composable API</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>ThreadPools.jl</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>ThreadPools.jl</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/tro3/ThreadPools.jl/blob/master/docs/src/index.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="ThreadPools.jl"><a class="docs-heading-anchor" href="#ThreadPools.jl">ThreadPools.jl</a><a id="ThreadPools.jl-1"></a><a class="docs-heading-anchor-permalink" href="#ThreadPools.jl" title="Permalink"></a></h1><p><em>Improved thread management for background and nonuniform tasks</em></p><h2 id="Overview"><a class="docs-heading-anchor" href="#Overview">Overview</a><a id="Overview-1"></a><a class="docs-heading-anchor-permalink" href="#Overview" title="Permalink"></a></h2><p>Documentation at https://tro3.github.io/ThreadPools.jl</p><p>ThreadPools.jl is a simple package that exposes a few macros and functions that mimic <code>Base.Threads.@threads</code>, <code>Base.map</code>, and <code>Base.foreach</code>. These  macros (and the underlying API) handle cases that the built-in functions are  not always well-suited for:</p><ul><li>A group of tasks that the user wants to keep off of the primary thread</li><li>A group of tasks that are very nonuniform in duration</li></ul><p>For the first case, ThreadPools exposes a <a href="#ThreadPools.@bthreads"><code>@bthreads</code></a> (&quot;background threads&quot;)  macro that behaves identically to <code>Threads.@threads</code>, but keeps the primary thread job-free.  There are also related <a href="#ThreadPools.bmap-Tuple{Any,Any}"><code>bmap</code></a> and <a href="#ThreadPools.bforeach-Tuple{Any,Any}"><code>bforeach</code></a> functions that mimic their <code>Base</code> counterparts, but with the same non-primary  thread usage.</p><p>For the second case, the package exposes a <a href="#ThreadPools.@qthreads"><code>@qthreads</code></a> (&quot;queued threads&quot;)  macro. This macro uses a different scheduling strategy to help with nonuniform jobs.  <code>@threads</code> and <code>@bthreads</code> first divide the incoming job list into equal job  &quot;chunks&quot;, then launch each  chunk on a separate thread for processing.  If the jobs are not uniform, this can lead to some long jobs all getting assigned to one thread, delaying  completion.  <code>@qthreads</code> does not pre-assign threads - it only starts a new  job as an old one finishes, so if a long job comes along, the other threads  will keep operating on the shorter ones.  <code>@qthreads</code> itself does use the  primary thread, but its cousin <a href="#ThreadPools.@qbthreads"><code>@qbthreads</code></a> uses the same strategy  but in the background. There are also <a href="#ThreadPools.qmap-Tuple{Any,Any}"><code>qmap</code></a>, <a href="#ThreadPools.qforeach-Tuple{Any,Any}"><code>qforeach</code></a>,  <a href="#ThreadPools.qbmap-Tuple{Any,Any}"><code>qbmap</code></a>, and <a href="#ThreadPools.qbforeach-Tuple{Any,Any}"><code>qbforeach</code></a>.</p><p>The package also exposes a lower-level <a href="#ThreadPools.@tspawnat"><code>@tspawnat</code></a> macro that mimics the  <code>Base.Threads.@spawn</code> macro but allows direct thread assignment for users who want  to develop their own scheduling and a <a href="#ThreadPools.spawnbg-Tuple{Any}"><code>spawnbg</code></a> function that will spawn  a function onto an available background thread.</p><h3 id="Simple-Macro/Function-Selection"><a class="docs-heading-anchor" href="#Simple-Macro/Function-Selection">Simple Macro/Function Selection</a><a id="Simple-Macro/Function-Selection-1"></a><a class="docs-heading-anchor-permalink" href="#Simple-Macro/Function-Selection" title="Permalink"></a></h3><table><tr><th style="text-align: left">Task Type</th><th style="text-align: left">Foreground (primary allowed)</th><th style="text-align: left">Background (primary forbidden)</th></tr><tr><td style="text-align: left"><strong>Uniform tasks</strong></td><td style="text-align: left"><code>Base.Threads.@threads</code> <code>ThreadPools.tmap(fn, itrs)</code> <code>ThreadPools.tforeach(fn, itrs)</code></td><td style="text-align: left"><code>ThreadPools.@bthreads</code> <code>ThreadPools.bmap(fn, itrs)</code> <code>ThreadPools.bforeach(fn, itrs)</code></td></tr><tr><td style="text-align: left"><strong>Nonuniform tasks</strong></td><td style="text-align: left"><code>ThreadPools.@qthreads</code> <code>ThreadPools.qmap(fn, itrs)</code> <code>ThreadPools.qforeach(fn, itrs)</code></td><td style="text-align: left"><code>ThreadPools.@qbthreads</code> <code>ThreadPools.qbmap(fn, itrs)</code> <code>ThreadPools.qbforeach(fn, itrs)</code></td></tr></table><h3 id="Job-Logging-for-Performance-Tuning"><a class="docs-heading-anchor" href="#Job-Logging-for-Performance-Tuning">Job Logging for Performance Tuning</a><a id="Job-Logging-for-Performance-Tuning-1"></a><a class="docs-heading-anchor-permalink" href="#Job-Logging-for-Performance-Tuning" title="Permalink"></a></h3><p>Each of the above macros comes with a logging version that allows the user to  analyze the performance of the chosen strategy and thread count:</p><table><tr><th style="text-align: left">Task Type</th><th style="text-align: left">Foreground</th><th style="text-align: left">Background</th></tr><tr><td style="text-align: left"><strong>Uniform tasks</strong></td><td style="text-align: left"><code>ThreadPools.@logthreads</code> <code>ThreadPools.logtmap(fn, itrs)</code> <code>ThreadPools.logtforeach(fn, itrs)</code></td><td style="text-align: left"><code>ThreadPools.@logbthreads</code> <code>ThreadPools.logbmap(fn, itrs)</code> <code>ThreadPools.logbforeach(fn, itrs)</code></td></tr><tr><td style="text-align: left"><strong>Nonuniform tasks</strong></td><td style="text-align: left"><code>ThreadPools.@logqthreads</code> <code>ThreadPools.logqmap(fn, itrs)</code> <code>ThreadPools.logqforeach(fn, itrs)</code></td><td style="text-align: left"><code>ThreadPools.@logqbthreads</code> <code>ThreadPools.logqbmap(fn, itrs)</code> <code>ThreadPools.logqbforeach(fn, itrs)</code></td></tr></table><p>Please see below for usage examples.</p><h2 id="Usage"><a class="docs-heading-anchor" href="#Usage">Usage</a><a id="Usage-1"></a><a class="docs-heading-anchor-permalink" href="#Usage" title="Permalink"></a></h2><p>Each of the simple API functions can be used like the <code>Base</code> versions of the  same function: </p><pre><code class="language-julia">julia&gt; @qbthreads for x in 1:3
         println(&quot;$x $(Threads.threadid())&quot;)
       end
2 3
3 4
1 2

julia&gt; bmap([1,2,3]) do x
         println(&quot;$x $(Threads.threadid())&quot;)
         x^2
       end
2 3
3 4
1 2
3-element Array{Int64,1}:
 1
 4
 9

julia&gt; t = @tspawnat 4 Threads.threadid()
Task (runnable) @0x0000000010743c70

julia&gt; fetch(t)
4</code></pre><p>Note that both of the above examples use the background versions and no  threadid==1 is seen.  Also note that while the execution order is not  guaranteed across threads, but the result of <code>bmap</code> will of course match  the input. </p><h2 id="Logger-Usage"><a class="docs-heading-anchor" href="#Logger-Usage">Logger Usage</a><a id="Logger-Usage-1"></a><a class="docs-heading-anchor-permalink" href="#Logger-Usage" title="Permalink"></a></h2><p>The logging versions of the above functions all produce an <code>AbstractThreadPool</code>  object that has an in-memory log of the start and stop times of each job that  ran through the pool.  A <code>PlotRecipe</code> from <code>RecipesBase</code> is exposed in the  package, so all that is needed to generate a visualization of the job times is  the <code>plot</code> command from <code>Plots</code>.  In these plots, each job is shown by index, start time, and stop time and is given a color corresponding to its thread:</p><pre><code class="language-julia">julia&gt; using Plots

julia&gt; pool = logtforeach(x -&gt; sleep(0.1*x), 1:8);

julia&gt; plot(pool)</code></pre><p><img src="img/staticlog.png" alt="tforeach plot"/></p><pre><code class="language-julia">julia&gt; pool = logqforeach(x -&gt; sleep(0.1*x), 1:8);

julia&gt; plot(pool)</code></pre><p><img src="img/qlog.png" alt="qforeach plot"/></p><p>Note the two different scheduling strategies are seen in the above plots. The  <code>tforeach</code> log shows that the jobs were assigned in order: 1 &amp; 2 to  thread 1, 3 &amp; 4 to thread 2, and so on.  The <code>qforeach</code> shows that each job (any thread) is started when the previous job on that thread completes. Because these jobs are very nonuniform (and stacked against the first strategy), this results in the pre-assign method taking 25% longer.</p><h2 id="Simple-API"><a class="docs-heading-anchor" href="#Simple-API">Simple API</a><a id="Simple-API-1"></a><a class="docs-heading-anchor-permalink" href="#Simple-API" title="Permalink"></a></h2><p>Each function of the simple API tries to mimic an existing function in <code>Base</code>  or <code>Base.Threads</code> to keep any code rework to a minimum.</p><h3 id="Regular-Versions"><a class="docs-heading-anchor" href="#Regular-Versions">Regular Versions</a><a id="Regular-Versions-1"></a><a class="docs-heading-anchor-permalink" href="#Regular-Versions" title="Permalink"></a></h3><ul><li><a href="#ThreadPools.@bthreads"><code>@bthreads</code></a></li><li><a href="#ThreadPools.@qthreads"><code>@qthreads</code></a></li><li><a href="#ThreadPools.@qbthreads"><code>@qbthreads</code></a></li><li><a href="#ThreadPools.tmap-Tuple{Function,Any}"><code>tmap(fn, itr)</code></a></li><li><a href="#ThreadPools.bmap-Tuple{Any,Any}"><code>bmap(fn, itr)</code></a></li><li><a href="#ThreadPools.qmap-Tuple{Any,Any}"><code>qmap(fn, itr)</code></a></li><li><a href="#ThreadPools.qbmap-Tuple{Any,Any}"><code>qbmap(fn, itr)</code></a></li><li><a href="#ThreadPools.tforeach-Tuple{Function,Any}"><code>tforeach(fn, itr)</code></a></li><li><a href="#ThreadPools.bforeach-Tuple{Any,Any}"><code>bforeach(fn, itr)</code></a></li><li><a href="#ThreadPools.qforeach-Tuple{Any,Any}"><code>qforeach(fn, itr)</code></a></li><li><a href="#ThreadPools.qbforeach-Tuple{Any,Any}"><code>qbforeach(fn, itr)</code></a></li></ul><h3 id="Logging-Versions"><a class="docs-heading-anchor" href="#Logging-Versions">Logging Versions</a><a id="Logging-Versions-1"></a><a class="docs-heading-anchor-permalink" href="#Logging-Versions" title="Permalink"></a></h3><ul><li><a href="#ThreadPools.@logthreads"><code>@logthreads</code></a></li><li><a href="#ThreadPools.@logbthreads"><code>@logbthreads</code></a></li><li><a href="#ThreadPools.@logqthreads"><code>@logqthreads</code></a></li><li><a href="#ThreadPools.@logqbthreads"><code>@logqbthreads</code></a></li><li><a href="#ThreadPools.logtmap-Tuple{Function,Any}"><code>logtmap(fn, itr)</code></a></li><li><a href="#ThreadPools.logbmap-Tuple{Any,Any}"><code>logbmap(fn, itr)</code></a></li><li><a href="#ThreadPools.logqmap-Tuple{Any,Any}"><code>logqmap(fn, itr)</code></a></li><li><a href="#ThreadPools.logqbmap-Tuple{Any,Any}"><code>logqbmap(fn, itr)</code></a></li><li><a href="#ThreadPools.logtforeach-Tuple{Function,Any}"><code>logtforeach(fn, itr)</code></a></li><li><a href="#ThreadPools.logbforeach-Tuple{Any,Any}"><code>logbforeach(fn, itr)</code></a></li><li><a href="#ThreadPools.logqforeach-Tuple{Any,Any}"><code>logqforeach(fn, itr)</code></a></li><li><a href="#ThreadPools.logqbforeach-Tuple{Any,Any}"><code>logqbforeach(fn, itr)</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="ThreadPools.@bthreads" href="#ThreadPools.@bthreads"><code>ThreadPools.@bthreads</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@bthreads</code></pre><p>Mimics <code>Base.Threads.@threads, but keeps the iterated tasks off if the primary  thread.</code></p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; @bthreads for x in 1:8
         println((x, Threads.threadid()))
       end
(1, 2)
(6, 4)
(3, 3)
(7, 4)
(4, 3)
(8, 4)
(5, 3)
(2, 2)</code></pre><p>Note that execution order is not guaranteed, but the primary thread does not show up on any of the jobs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tro3/ThreadPools.jl/blob/f4b47460efa3e1df0d5291df3c09f0977dac50c4/src/macros.jl#L34-L56">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ThreadPools.@qthreads" href="#ThreadPools.@qthreads"><code>ThreadPools.@qthreads</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@qthreads</code></pre><p>Mimics <code>Base.Threads.@threads</code>, but uses a task queueing strategy, only starting  a new task when an previous one (on any thread) has completed.  This can provide performance advantages when the iterated tasks are very nonuniform in length.  The primary thread is used.  To prevent usage of the primary thread, see  <a href="#ThreadPools.@qbthreads"><code>@qbthreads</code></a>.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; @qthreads for x in 1:8
         println((x, Threads.threadid()))
       end
(2, 4)
(3, 3)
(4, 2)
(5, 4)
(6, 3)
(7, 2)
(8, 4)
(1, 1)</code></pre><p>Note that execution order is not guaranteed and the primary thread is used.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tro3/ThreadPools.jl/blob/f4b47460efa3e1df0d5291df3c09f0977dac50c4/src/macros.jl#L62-L86">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ThreadPools.@qbthreads" href="#ThreadPools.@qbthreads"><code>ThreadPools.@qbthreads</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@qbthreads</code></pre><p>Mimics <code>Base.Threads.@threads</code>, but uses a task queueing strategy, only starting  a new task when an previous one (on any thread) has completed.  This can provide performance advantages when the iterated tasks are very nonuniform in length.  The primary thread is not used.  To allow usage of the primary thread, see  <a href="#ThreadPools.@qthreads"><code>@qthreads</code></a>.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; @qbthreads for x in 1:8
         println((x, Threads.threadid()))
       end
(2, 4)
(3, 2)
(1, 3)
(4, 4)
(5, 2)
(6, 3)
(7, 4)
(8, 2)</code></pre><p>Note that execution order is not guaranteed, but the primary thread does not show up on any of the jobs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tro3/ThreadPools.jl/blob/f4b47460efa3e1df0d5291df3c09f0977dac50c4/src/macros.jl#L91-L116">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ThreadPools.tmap-Tuple{Function,Any}" href="#ThreadPools.tmap-Tuple{Function,Any}"><code>ThreadPools.tmap</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">tmap(fn, itrs...) -&gt; collection</code></pre><p>Mimics <code>Base.map</code>, but launches the function evaluations onto all available  threads, using a pre-assigned scheduling strategy appropriate for uniform task durations.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; tmap(x -&gt; begin; println((x,Threads.threadid())); x^2; end, 1:8)&#39;
(7, 4)
(5, 3)
(8, 4)
(1, 1)
(6, 3)
(2, 1)
(3, 2)
(4, 2)
1×8 LinearAlgebra.Adjoint{Int64,Array{Int64,1}}:
 1  4  9  16  25  36  49  64</code></pre><p>Note that while the execution order is not guaranteed, the result order is.  Also note that the primary thread is used.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tro3/ThreadPools.jl/blob/f4b47460efa3e1df0d5291df3c09f0977dac50c4/src/simplefuncs.jl#L2-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ThreadPools.bmap-Tuple{Any,Any}" href="#ThreadPools.bmap-Tuple{Any,Any}"><code>ThreadPools.bmap</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">bmap(fn, itrs...) -&gt; collection</code></pre><p>Mimics <code>Base.map</code>, but launches the function evaluations onto all available  threads except the primary, using a pre-assigned scheduling strategy  appropriate for uniform task durations.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; bmap(x -&gt; begin; println((x,Threads.threadid())); x^2; end, 1:8)&#39;
(6, 4)
(1, 2)
(3, 3)
(2, 2)
(4, 3)
(7, 4)
(5, 3)
(8, 4)
1×8 LinearAlgebra.Adjoint{Int64,Array{Int64,1}}:
 1  4  9  16  25  36  49  64</code></pre><p>Note that while the execution order is not guaranteed, the result order is,  Also note that the primary thread is not used.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tro3/ThreadPools.jl/blob/f4b47460efa3e1df0d5291df3c09f0977dac50c4/src/simplefuncs.jl#L33-L56">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ThreadPools.qmap-Tuple{Any,Any}" href="#ThreadPools.qmap-Tuple{Any,Any}"><code>ThreadPools.qmap</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">qmap(fn, itrs...) -&gt; collection</code></pre><p>Mimics <code>Base.map</code>, but launches the function evaluations onto all available  threads, using a queued scheduling strategy appropriate for nonuniform task durations.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; qmap(x -&gt; begin; println((x,Threads.threadid())); x^2; end, 1:8)&#39;
(2, 3)
(3, 2)
(4, 4)
(5, 3)
(6, 2)
(7, 4)
(8, 3)
(1, 1)
1×8 LinearAlgebra.Adjoint{Int64,Array{Int64,1}}:
 1  4  9  16  25  36  49  64</code></pre><p>Note that while the execution order is not guaranteed, the result order is.  Also note that the primary thread is used.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tro3/ThreadPools.jl/blob/f4b47460efa3e1df0d5291df3c09f0977dac50c4/src/simplefuncs.jl#L64-L87">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ThreadPools.qbmap-Tuple{Any,Any}" href="#ThreadPools.qbmap-Tuple{Any,Any}"><code>ThreadPools.qbmap</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">qbmap(fn, itrs...) -&gt; collection</code></pre><p>Mimics <code>Base.map</code>, but launches the function evaluations onto all available  threads except the primary, using a queued scheduling strategy appropriate  for nonuniform task durations.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; qbmap(x -&gt; begin; println((x,Threads.threadid())); x^2; end, 1:8)&#39;
(2, 3)
(1, 2)
(3, 4)
(5, 2)
(4, 3)
(6, 4)
(7, 2)
(8, 3)
1×8 LinearAlgebra.Adjoint{Int64,Array{Int64,1}}:
 1  4  9  16  25  36  49  64</code></pre><p>Note that while the execution order is not guaranteed, the result order is,  Also note that the primary thread is not used.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tro3/ThreadPools.jl/blob/f4b47460efa3e1df0d5291df3c09f0977dac50c4/src/simplefuncs.jl#L95-L118">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ThreadPools.tforeach-Tuple{Function,Any}" href="#ThreadPools.tforeach-Tuple{Function,Any}"><code>ThreadPools.tforeach</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">tforeach(fn, itrs...)</code></pre><p>Mimics <code>Base.foreach</code>, but launches the function evaluations onto all available  threads, using a pre-assigned scheduling strategy appropriate for uniform task durations.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; tforeach(x -&gt; println((x,Threads.threadid())), 1:8)
(1, 1)
(3, 2)
(5, 3)
(2, 1)
(7, 4)
(4, 2)
(8, 4)
(6, 3)</code></pre><p>Note that the execution order is not guaranteed, and that the primary thread  is used.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tro3/ThreadPools.jl/blob/f4b47460efa3e1df0d5291df3c09f0977dac50c4/src/simplefuncs.jl#L283-L304">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ThreadPools.bforeach-Tuple{Any,Any}" href="#ThreadPools.bforeach-Tuple{Any,Any}"><code>ThreadPools.bforeach</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">bforeach(fn, itrs...)</code></pre><p>Mimics <code>Base.foreach</code>, but launches the function evaluations onto all available  threads except the primary, using a pre-assigned scheduling strategy appropriate  for uniform task durations.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; bforeach(x -&gt; println((x,Threads.threadid())), 1:8)
(1, 2)
(6, 4)
(2, 2)
(7, 4)
(8, 4)
(3, 3)
(4, 3)
(5, 3)</code></pre><p>Note that the execution order is not guaranteed, and that the primary thread  is not used.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tro3/ThreadPools.jl/blob/f4b47460efa3e1df0d5291df3c09f0977dac50c4/src/simplefuncs.jl#L313-L334">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ThreadPools.qforeach-Tuple{Any,Any}" href="#ThreadPools.qforeach-Tuple{Any,Any}"><code>ThreadPools.qforeach</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">qforeach(fn, itrs...)</code></pre><p>Mimics <code>Base.foreach</code>, but launches the function evaluations onto all available  threads, using a queued scheduling strategy appropriate for nonuniform task durations.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; qforeach(x -&gt; println((x,Threads.threadid())), 1:8)
(4, 3)
(2, 2)
(3, 4)
(5, 3)
(6, 2)
(7, 4)
(8, 3)
(1, 1)</code></pre><p>Note that the execution order is not guaranteed, and that the primary thread  is used.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tro3/ThreadPools.jl/blob/f4b47460efa3e1df0d5291df3c09f0977dac50c4/src/simplefuncs.jl#L342-L363">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ThreadPools.qbforeach-Tuple{Any,Any}" href="#ThreadPools.qbforeach-Tuple{Any,Any}"><code>ThreadPools.qbforeach</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">qbforeach(fn, itrs...)</code></pre><p>Mimics <code>Base.foreach</code>, but launches the function evaluations onto all available  threads except the primary, using a queued scheduling strategy appropriate for  nonuniform task durations.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; qbforeach(x -&gt; println((x,Threads.threadid())), 1:8)
(3, 3)
(2, 4)
(1, 2)
(4, 3)
(5, 4)
(6, 2)
(7, 3)
(8, 4)</code></pre><p>Note that the execution order is not guaranteed, and that the primary thread  is not used.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tro3/ThreadPools.jl/blob/f4b47460efa3e1df0d5291df3c09f0977dac50c4/src/simplefuncs.jl#L372-L393">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ThreadPools.@logthreads" href="#ThreadPools.@logthreads"><code>ThreadPools.@logthreads</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@logthreads -&gt; pool</code></pre><p>Mimics <code>Base.Threads.@threads</code>.  Returns a logged pool that can be analyzed with  the logging functions and <code>plot</code>ted.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; pool = @logthreads for x in 1:8
         println((x, Threads.threadid()))
       end;
(1, 1)
(5, 3)
(7, 4)
(2, 1)
(6, 3)
(8, 4)
(3, 2)
(4, 2)

julia&gt; plot(pool)</code></pre><p>Note that execution order is not guaranteed and the primary thread is used.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tro3/ThreadPools.jl/blob/f4b47460efa3e1df0d5291df3c09f0977dac50c4/src/macros.jl#L121-L144">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ThreadPools.@logbthreads" href="#ThreadPools.@logbthreads"><code>ThreadPools.@logbthreads</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@logbthreads -&gt; pool</code></pre><p>Mimics <code>Base.Threads.@threads, but keeps the iterated tasks off if the primary  thread.</code>  Returns a logged pool that can be analyzed with the logging functions  and <code>plot</code>ted.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; pool = @logbthreads for x in 1:8
         println((x, Threads.threadid()))
       end;
(3, 4)
(2, 3)
(1, 2)
(4, 4)
(5, 3)
(6, 2)
(8, 3)
(7, 4)

julia&gt; plot(pool)</code></pre><p>Note that execution order is not guaranteed, but the primary thread does not show up on any of the jobs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tro3/ThreadPools.jl/blob/f4b47460efa3e1df0d5291df3c09f0977dac50c4/src/macros.jl#L149-L174">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ThreadPools.@logqthreads" href="#ThreadPools.@logqthreads"><code>ThreadPools.@logqthreads</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@logqthreads -&gt; pool</code></pre><p>Mimics <code>Base.Threads.@threads</code>, but uses a task queueing strategy, only starting  a new task when an previous one (on any thread) has completed.  Returns a logged  pool that can be analyzed with the logging functions and <code>plot</code>ted. The primary  thread is used.  To prevent usage of the primary thread, see  <a href="#ThreadPools.@logqbthreads"><code>@logqbthreads</code></a>.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; pool = @logqthreads for x in 1:8
         println((x, Threads.threadid()))
       end;
(1, 1)
(3, 2)
(7, 4)
(5, 3)
(2, 1)
(8, 4)
(6, 3)
(4, 2)

julia&gt; plot(pool)</code></pre><p>Note that execution order is not guaranteed and the primary thread is used.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tro3/ThreadPools.jl/blob/f4b47460efa3e1df0d5291df3c09f0977dac50c4/src/macros.jl#L179-L205">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ThreadPools.@logqbthreads" href="#ThreadPools.@logqbthreads"><code>ThreadPools.@logqbthreads</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@logqbthreads -&gt; pool</code></pre><p>Mimics <code>Base.Threads.@threads</code>, but uses a task queueing strategy, only starting  a new task when an previous one (on any thread) has completed.  Returns a logged  pool that can be analyzed with the logging functions and <code>plot</code>ted. The primary  thread is not used.  To allow usage of the primary thread, see  <a href="#ThreadPools.@logqthreads"><code>@logqthreads</code></a>.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; pool = @logqbthreads for x in 1:8
         println((x, Threads.threadid()))
       end;
(2, 3)
(1, 4)
(3, 2)
(4, 3)
(5, 4)
(6, 2)
(7, 3)
(8, 4)

julia&gt; plot(pool)</code></pre><p>Note that execution order is not guaranteed, but the primary thread does not show up on any of the jobs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tro3/ThreadPools.jl/blob/f4b47460efa3e1df0d5291df3c09f0977dac50c4/src/macros.jl#L210-L237">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ThreadPools.logtmap-Tuple{Function,Any}" href="#ThreadPools.logtmap-Tuple{Function,Any}"><code>ThreadPools.logtmap</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">logtmap(fn, itrs...) -&gt; (pool, collection)</code></pre><p>Mimics <code>Base.map</code>, but launches the function evaluations onto all available  threads, using a pre-assigned scheduling strategy appropriate for uniform task durations.  Also returns a logged pool that can be analyzed with  the logging functions and <code>plot</code>ted.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; (pool, result) = logtmap(1:8) do x
         println((x,Threads.threadid()))
         x^2
       end;
(1, 1)
(3, 2)
(7, 4)
(5, 3)
(8, 4)
(4, 2)
(2, 1)
(6, 3)

julia&gt; result&#39;
1×8 LinearAlgebra.Adjoint{Int64,Array{Int64,1}}:
1  4  9  16  25  36  49  64

julia&gt; plot(pool)</code></pre><p>Note that while the execution order is not guaranteed, the result order is.  Also note that the primary thread is used.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tro3/ThreadPools.jl/blob/f4b47460efa3e1df0d5291df3c09f0977dac50c4/src/simplefuncs.jl#L126-L157">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ThreadPools.logbmap-Tuple{Any,Any}" href="#ThreadPools.logbmap-Tuple{Any,Any}"><code>ThreadPools.logbmap</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">logbmap(fn, itrs...) -&gt; (pool, collection)</code></pre><p>Mimics <code>Base.map</code>, but launches the function evaluations onto all available  threads except the primary, using a pre-assigned scheduling strategy  appropriate for uniform task durations.  Also returns a logged pool that can  be analyzed with the logging functions and <code>plot</code>ted.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; (pool, result) = logbmap(1:8) do x
         println((x,Threads.threadid()))
         x^2
       end;
(1, 2)
(6, 4)
(3, 3)
(7, 4)
(2, 2)
(4, 3)
(8, 4)
(5, 3)

julia&gt; result&#39;
1×8 LinearAlgebra.Adjoint{Int64,Array{Int64,1}}:
1  4  9  16  25  36  49  64

julia&gt; plot(pool)</code></pre><p>Note that while the execution order is not guaranteed, the result order is,  Also note that the primary thread is not used.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tro3/ThreadPools.jl/blob/f4b47460efa3e1df0d5291df3c09f0977dac50c4/src/simplefuncs.jl#L165-L196">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ThreadPools.logqmap-Tuple{Any,Any}" href="#ThreadPools.logqmap-Tuple{Any,Any}"><code>ThreadPools.logqmap</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">logqmap(fn, itrs...) -&gt; (pool, collection)</code></pre><p>Mimics <code>Base.map</code>, but launches the function evaluations onto all available  threads, using a queued scheduling strategy appropriate for nonuniform task durations.  Also returns a logged pool that can be analyzed with the  logging functions and <code>plot</code>ted.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; (pool, result) = logqmap(1:8) do x
         println((x,Threads.threadid()))
         x^2
        end;
(3, 3)
(4, 4)
(2, 2)
(5, 3)
(7, 2)
(6, 4)
(8, 3)
(1, 1)

julia&gt; result&#39;
1×8 LinearAlgebra.Adjoint{Int64,Array{Int64,1}}:
1  4  9  16  25  36  49  64

julia&gt; plot(pool)</code></pre><p>Note that while the execution order is not guaranteed, the result order is.  Also note that the primary thread is used.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tro3/ThreadPools.jl/blob/f4b47460efa3e1df0d5291df3c09f0977dac50c4/src/simplefuncs.jl#L204-L235">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ThreadPools.logqbmap-Tuple{Any,Any}" href="#ThreadPools.logqbmap-Tuple{Any,Any}"><code>ThreadPools.logqbmap</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">logqbmap(fn, itrs...) -&gt; (pool, collection)</code></pre><p>Mimics <code>Base.map</code>, but launches the function evaluations onto all available  threads except the primary, using a queued scheduling strategy appropriate  for nonuniform task durations.  Also returns a logged pool that can be  analyzed with the logging functions and <code>plot</code>ted.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; (pool, result) = logqbmap(1:8) do x
         println((x,Threads.threadid()))
         x^2
       end;
(3, 3)
(2, 4)
(1, 2)
(4, 3)
(5, 4)
(6, 2)
(7, 3)
(8, 4)

julia&gt; result&#39;
1×8 LinearAlgebra.Adjoint{Int64,Array{Int64,1}}:
1  4  9  16  25  36  49  64

julia&gt; plot(pool)</code></pre><p>Note that while the execution order is not guaranteed, the result order is,  Also note that the primary thread is not used.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tro3/ThreadPools.jl/blob/f4b47460efa3e1df0d5291df3c09f0977dac50c4/src/simplefuncs.jl#L243-L274">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ThreadPools.logtforeach-Tuple{Function,Any}" href="#ThreadPools.logtforeach-Tuple{Function,Any}"><code>ThreadPools.logtforeach</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">logtforeach(fn, itrs...) -&gt; pool</code></pre><p>Mimics <code>Base.foreach</code>, but launches the function evaluations onto all available  threads, using a pre-assigned scheduling strategy appropriate for uniform task durations.  Returns a logged pool that can be analyzed with  the logging functions and <code>plot</code>ted.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; pool = logtforeach(x -&gt; println((x,Threads.threadid())), 1:8);
(1, 1)
(3, 2)
(7, 4)
(2, 1)
(4, 2)
(5, 3)
(8, 4)
(6, 3)

julia&gt; plot(pool)</code></pre><p>Note that the execution order is not guaranteed, and that the primary thread  is used.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tro3/ThreadPools.jl/blob/f4b47460efa3e1df0d5291df3c09f0977dac50c4/src/simplefuncs.jl#L403-L427">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ThreadPools.logbforeach-Tuple{Any,Any}" href="#ThreadPools.logbforeach-Tuple{Any,Any}"><code>ThreadPools.logbforeach</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">logbforeach(fn, itrs...)</code></pre><p>Mimics <code>Base.foreach</code>, but launches the function evaluations onto all available  threads except the primary, using a pre-assigned scheduling strategy appropriate  for uniform task durations.  Returns a logged pool that can be analyzed with  the logging functions and <code>plot</code>ted.    </p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; pool = logbforeach(x -&gt; println((x,Threads.threadid())), 1:8);
(1, 2)
(3, 3)
(6, 4)
(4, 3)
(2, 2)
(7, 4)
(5, 3)
(8, 4)

julia&gt; plot(pool)</code></pre><p>Note that the execution order is not guaranteed, and that the primary thread  is not used.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tro3/ThreadPools.jl/blob/f4b47460efa3e1df0d5291df3c09f0977dac50c4/src/simplefuncs.jl#L436-L460">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ThreadPools.logqforeach-Tuple{Any,Any}" href="#ThreadPools.logqforeach-Tuple{Any,Any}"><code>ThreadPools.logqforeach</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">logqforeach(fn, itrs...)</code></pre><p>Mimics <code>Base.foreach</code>, but launches the function evaluations onto all available  threads, using a queued scheduling strategy appropriate for nonuniform task durations.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; pool = logqforeach(x -&gt; println((x,Threads.threadid())), 1:8);
(2, 4)
(3, 3)
(4, 2)
(5, 4)
(6, 3)
(7, 2)
(8, 4)
(1, 1)

julia&gt; plot(pool)</code></pre><p>Note that the execution order is not guaranteed, and that the primary thread  is used.  Returns a logged pool that can be analyzed with the logging functions  and <code>plot</code>ted.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tro3/ThreadPools.jl/blob/f4b47460efa3e1df0d5291df3c09f0977dac50c4/src/simplefuncs.jl#L469-L493">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ThreadPools.logqbforeach-Tuple{Any,Any}" href="#ThreadPools.logqbforeach-Tuple{Any,Any}"><code>ThreadPools.logqbforeach</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">logqbforeach(fn, itrs...)</code></pre><p>Mimics <code>Base.foreach</code>, but launches the function evaluations onto all available  threads except the primary, using a queued scheduling strategy appropriate for  nonuniform task durations.  Returns a logged pool that can be analyzed with the  logging functions and <code>plot</code>ted.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; pool = logqbforeach(x -&gt; println((x,Threads.threadid())), 1:8);
(2, 2)
(1, 3)
(3, 4)
(4, 2)
(5, 3)
(6, 4)
(7, 2)
(8, 3)

julia&gt; plot(pool)</code></pre><p>Note that the execution order is not guaranteed, and that the primary thread  is not used.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tro3/ThreadPools.jl/blob/f4b47460efa3e1df0d5291df3c09f0977dac50c4/src/simplefuncs.jl#L502-L526">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ThreadPools.@tspawnat" href="#ThreadPools.@tspawnat"><code>ThreadPools.@tspawnat</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@tspawnat tid -&gt; task</code></pre><p>Mimics <code>Base.Threads.@spawn</code>, but assigns the task to thread <code>tid</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; t = @tspawnat 4 Threads.threadid()
Task (runnable) @0x0000000010743c70

julia&gt; fetch(t)
4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tro3/ThreadPools.jl/blob/f4b47460efa3e1df0d5291df3c09f0977dac50c4/src/macros.jl#L243-L256">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ThreadPools.spawnbg-Tuple{Any}" href="#ThreadPools.spawnbg-Tuple{Any}"><code>ThreadPools.spawnbg</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">spawnbg(f)</code></pre><p>Spawn work on any available background thread. Captures any exception thrown in the thread, to give better stacktraces.</p><p>You can use <code>checked_fetch(spawnbg(f))</code> to rethrow any exception.</p><pre><code class="language-none">** Warning ** this doesn&#39;t compose with other ways of scheduling threads
So, one should use `spawn_background` exclusively in each Julia process.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tro3/ThreadPools.jl/blob/f4b47460efa3e1df0d5291df3c09f0977dac50c4/src/spawn_background.jl#L13-L23">source</a></section></article><h2 id="Composable-API"><a class="docs-heading-anchor" href="#Composable-API">Composable API</a><a id="Composable-API-1"></a><a class="docs-heading-anchor-permalink" href="#Composable-API" title="Permalink"></a></h2><h3 id="Functions"><a class="docs-heading-anchor" href="#Functions">Functions</a><a id="Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Functions" title="Permalink"></a></h3><p>The above macros invoke two base structures, <a href="#ThreadPools.StaticPool-Tuple{}"><code>ThreadPools.StaticPool</code></a> and  <a href="#ThreadPools.QueuePool-Tuple{}"><code>ThreadPools.QueuePool</code></a>, each of which can be assigned to a subset of the  available threads.  This allows for composition with the <code>twith</code> and <code>@tthreads</code>  commands, and usage in more complex scenarios, such as stack processing.</p><article class="docstring"><header><a class="docstring-binding" id="ThreadPools.twith-Tuple{Function,Any}" href="#ThreadPools.twith-Tuple{Function,Any}"><code>ThreadPools.twith</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">twith(fn, pool) -&gt; pool</code></pre><p>Apply the functon <code>fn</code> to the provided pool and close the pool.  Returns the  closed pool for any desired analysis or plotting. </p><p><strong>Example</strong></p><pre><code class="language-none">julia&gt; twith(ThreadPools.QueuePool(1,2)) do pool
         tforeach(x -&gt; println((x,Threads.threadid())), pool, 1:8)
       end;
(2, 2)
(1, 1)
(3, 2)
(4, 1)
(5, 2)
(6, 1)
(7, 2)
(8, 1)</code></pre><p>Note in the above example, only two threads were used, as set by the  <code>QueuePool</code> setting.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tro3/ThreadPools.jl/blob/f4b47460efa3e1df0d5291df3c09f0977dac50c4/src/interface.jl#L67-L89">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ThreadPools.@tthreads" href="#ThreadPools.@tthreads"><code>ThreadPools.@tthreads</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@tthreads pool</code></pre><p>Mimic the <code>Base.Threads.@threads</code> macro, but uses the provided pool to  assign the tasks.</p><p><strong>Example</strong></p><pre><code class="language-none">julia&gt; twith(ThreadPools.QueuePool(1,2)) do pool
         @tthreads pool for x in 1:8
           println((x,Threads.threadid()))
         end
       end;
(2, 2)
(3, 2)
(1, 1)
(4, 2)
(5, 1)
(6, 2)
(8, 2)
(7, 1)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tro3/ThreadPools.jl/blob/f4b47460efa3e1df0d5291df3c09f0977dac50c4/src/interface.jl#L97-L119">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ThreadPools.tmap-Tuple{Any,ThreadPools.AbstractThreadPool,Any,Vararg{Any,N} where N}" href="#ThreadPools.tmap-Tuple{Any,ThreadPools.AbstractThreadPool,Any,Vararg{Any,N} where N}"><code>ThreadPools.tmap</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">tmap(fn, pool, itr)</code></pre><p>Mimics <code>Base.map</code>, but launches the function evaluations onto the provided  pool to assign the tasks.</p><p><strong>Example</strong></p><pre><code class="language-none">julia&gt; pool = twith(ThreadPools.LoggedQueuePool(1,2)) do pool
         tmap(pool, 1:8) do x
           println((x,Threads.threadid()))
         end
       end;
(2, 2)
(1, 1)
(3, 2)
(4, 1)
(5, 2)
(6, 1)
(7, 2)
(8, 1)

julia&gt; plot(pool)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tro3/ThreadPools.jl/blob/f4b47460efa3e1df0d5291df3c09f0977dac50c4/src/interface.jl#L39-L63">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ThreadPools.tforeach-Tuple{Any,ThreadPools.AbstractThreadPool,Any}" href="#ThreadPools.tforeach-Tuple{Any,ThreadPools.AbstractThreadPool,Any}"><code>ThreadPools.tforeach</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">tforeach(fn, pool, itr)</code></pre><p>Mimics <code>Base.foreach</code>, but launches the function evaluations onto the provided  pool to assign the tasks.</p><p><strong>Example</strong></p><pre><code class="language-none">julia&gt; pool = twith(ThreadPools.LoggedQueuePool(1,2)) do pool
         tforeach(x -&gt; println((x,Threads.threadid())), pool, 1:8)
       end;
(2, 2)
(1, 1)
(3, 2)
(5, 2)
(4, 1)
(6, 2)
(7, 1)
(8, 2)

julia&gt; plot(pool)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tro3/ThreadPools.jl/blob/f4b47460efa3e1df0d5291df3c09f0977dac50c4/src/interface.jl#L8-L30">source</a></section></article><h3 id="AbstractThreadPool"><a class="docs-heading-anchor" href="#AbstractThreadPool">AbstractThreadPool</a><a id="AbstractThreadPool-1"></a><a class="docs-heading-anchor-permalink" href="#AbstractThreadPool" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="Base.close-Tuple{ThreadPools.StaticPool}" href="#Base.close-Tuple{ThreadPools.StaticPool}"><code>Base.close</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Base.close(pool::AbstractThreadPool)</code></pre><p>Closes the pool, shuts down any handlers and finalizes any logging activities. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tro3/ThreadPools.jl/blob/f4b47460efa3e1df0d5291df3c09f0977dac50c4/src/interface.jl#L152-L156">source</a></section></article><h3 id="StaticPools"><a class="docs-heading-anchor" href="#StaticPools">StaticPools</a><a id="StaticPools-1"></a><a class="docs-heading-anchor-permalink" href="#StaticPools" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="ThreadPools.StaticPool-Tuple{}" href="#ThreadPools.StaticPool-Tuple{}"><code>ThreadPools.StaticPool</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">StaticPool(init_thrd=1, nthrds=Threads.nthreads())</code></pre><p>The main StaticPool object.   </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tro3/ThreadPools.jl/blob/f4b47460efa3e1df0d5291df3c09f0977dac50c4/src/staticpool.jl#L16-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ThreadPools.LoggedStaticPool-Tuple{}" href="#ThreadPools.LoggedStaticPool-Tuple{}"><code>ThreadPools.LoggedStaticPool</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">LoggedStaticPool(init_thrd=1, nthrds=Threads.nthreads())</code></pre><p>The main LoggedStaticPool object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tro3/ThreadPools.jl/blob/f4b47460efa3e1df0d5291df3c09f0977dac50c4/src/logstaticpool.jl#L19-L23">source</a></section></article><h3 id="QueuePools"><a class="docs-heading-anchor" href="#QueuePools">QueuePools</a><a id="QueuePools-1"></a><a class="docs-heading-anchor-permalink" href="#QueuePools" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="ThreadPools.QueuePool-Tuple{}" href="#ThreadPools.QueuePool-Tuple{}"><code>ThreadPools.QueuePool</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">QueuePool(init_thrd=1, nthrds=Threads.nthreads())</code></pre><p>The main QueuePool object. Its API mimics that of a <code>Channel{Task}</code>, but each submitted task is executed on a different thread.  If <code>allow_primary</code> is true,  the assigned thread might be the primary, which will interfere with future  thread management for the duration of any heavy-computational (blocking) processes.  If it is false, all assigned threads will be off of the primary. Each thread will only be allowed one Task at a time, but each thread will  backfill with the next queued Task immediately on completion of the previous, without regard to how bust the other threads may be.  </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tro3/ThreadPools.jl/blob/f4b47460efa3e1df0d5291df3c09f0977dac50c4/src/qpool.jl#L43-L54">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ThreadPools.LoggedQueuePool-Tuple{}" href="#ThreadPools.LoggedQueuePool-Tuple{}"><code>ThreadPools.LoggedQueuePool</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">LoggedQueuePool(init_thrd=1, nthrds=Threads.nthreads())</code></pre><p>The main LoggedQueuePool object. Its API mimics that of a <code>Channel{Task}</code>, but each submitted task is executed on a different thread.  If <code>allow_primary</code> is true,  the assigned thread might be the primary, which will interfere with future  thread management for the duration of any heavy-computational (blocking) processes.  If it is false, all assigned threads will be off of the primary. Each thread will only be allowed one Task at a time, but each thread will  backfill with the next queued Task immediately on completion of the previous, without regard to how bust the other threads may be.</p><p>The API for the <code>LoggedQueuePool</code> is Identical to that for <a href="#ThreadPools.QueuePool-Tuple{}"><code>QueuePool</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tro3/ThreadPools.jl/blob/f4b47460efa3e1df0d5291df3c09f0977dac50c4/src/logqpool.jl#L54-L67">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.put!-Tuple{ThreadPools.QueuePool,Task}" href="#Base.put!-Tuple{ThreadPools.QueuePool,Task}"><code>Base.put!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Base.put!(pool::QueuePool, t::Task)</code></pre><p>Put the task <code>t</code> into the pool, blocking until the pool has an available thread.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tro3/ThreadPools.jl/blob/f4b47460efa3e1df0d5291df3c09f0977dac50c4/src/qpool.jl#L67-L72">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.put!-Tuple{ThreadPools.QueuePool,Function,Vararg{Any,N} where N}" href="#Base.put!-Tuple{ThreadPools.QueuePool,Function,Vararg{Any,N} where N}"><code>Base.put!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Base.put!(pool::QueuePool, fn, args...)
Base.put!(fn, pool::QueuePool, args...)</code></pre><p>Creates a task that runs <code>fn(args...)</code> and adds it to the pool, blocking  until the pool has an available thread.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tro3/ThreadPools.jl/blob/f4b47460efa3e1df0d5291df3c09f0977dac50c4/src/qpool.jl#L79-L85">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.take!-Tuple{ThreadPools.QueuePool}" href="#Base.take!-Tuple{ThreadPools.QueuePool}"><code>Base.take!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Base.take!(pool::QueuePool) -&gt; Task</code></pre><p>Takes the next available completed task from the pool, blocking until a task is available.  </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tro3/ThreadPools.jl/blob/f4b47460efa3e1df0d5291df3c09f0977dac50c4/src/qpool.jl#L90-L95">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.iterate-Tuple{ThreadPools.QueuePool,Any}" href="#Base.iterate-Tuple{ThreadPools.QueuePool,Any}"><code>Base.iterate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Base.iterate(pool::QueuePool[, state])</code></pre><p>Iterates over the completed Tasks, grabbing the next one available and ending when the pool has been <code>close</code>ed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tro3/ThreadPools.jl/blob/f4b47460efa3e1df0d5291df3c09f0977dac50c4/src/qpool.jl#L117-L122">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ThreadPools.poolresults-Tuple{ThreadPools.QueuePool}" href="#ThreadPools.poolresults-Tuple{ThreadPools.QueuePool}"><code>ThreadPools.poolresults</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">poolresults(pool::QueuePool) -&gt; result iterator</code></pre><p>Returns an iterator over the <code>fetch</code>ed results of the pooled tasks.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; pool = QueuePool();

julia&gt; @async begin
         for i in 1:4
           put!(pool, x -&gt; 2*x, i)
         end
         close(pool)
       end;

julia&gt; for r in poolresults(pool)
         println(r)
       end
6
2
4
8</code></pre><p>Note that the execution order across the threads is not guaranteed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tro3/ThreadPools.jl/blob/f4b47460efa3e1df0d5291df3c09f0977dac50c4/src/qpool.jl#L146-L172">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ThreadPools.isactive-Tuple{ThreadPools.QueuePool}" href="#ThreadPools.isactive-Tuple{ThreadPools.QueuePool}"><code>ThreadPools.isactive</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ThreadPools.isactive(pool::QueuePool)</code></pre><p>Returns <code>true</code> if there are queued Tasks anywhere in the pool, either awaiting execution, executing, or waiting to be retrieved.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tro3/ThreadPools.jl/blob/f4b47460efa3e1df0d5291df3c09f0977dac50c4/src/qpool.jl#L128-L133">source</a></section></article></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Saturday 18 September 2021 11:43">Saturday 18 September 2021</span>. Using Julia version 1.5.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
