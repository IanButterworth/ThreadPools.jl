<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>ThreadPools.jl Documentation · ThreadPool Documentation</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">ThreadPool Documentation</span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>ThreadPools.jl Documentation</a><ul class="internal"><li><a class="tocitem" href="#Overview-1"><span>Overview</span></a></li><li><a class="tocitem" href="#Usage-1"><span>Usage</span></a></li><li><a class="tocitem" href="#Demonstrations-1"><span>Demonstrations</span></a></li><li><a class="tocitem" href="#Simple-API-1"><span>Simple API</span></a></li><li class="toplevel"><a class="tocitem" href="#ThreadPool-API-1"><span>ThreadPool API</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>ThreadPools.jl Documentation</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>ThreadPools.jl Documentation</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/tro3/ThreadPool.jl/blob/master/docs/src/index.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="ThreadPools.jl-Documentation-1"><a class="docs-heading-anchor" href="#ThreadPools.jl-Documentation-1">ThreadPools.jl Documentation</a><a class="docs-heading-anchor-permalink" href="#ThreadPools.jl-Documentation-1" title="Permalink"></a></h1><p><em>Improved background Task management, keeping heavy Julia computations off the primary thread</em></p><p>A simple package that creates a few functions mimicked from <code>Base</code> (<a href="#ThreadPools.bgforeach-Tuple{Any,Any}"><code>bgforeach</code></a>, <a href="#ThreadPools.bgmap-Tuple{Any,Any}"><code>bgmap</code></a>, and <a href="#ThreadPools.@bgthreads"><code>@bgthreads</code></a>) that behave like the originals but generate spawned tasks  that stay purely on background threads.</p><h2 id="Overview-1"><a class="docs-heading-anchor" href="#Overview-1">Overview</a><a class="docs-heading-anchor-permalink" href="#Overview-1" title="Permalink"></a></h2><p>As of v1.3.1, Julia does not have any built-in mechanisms for keeping  computational threads off of the primary thread.  For many use cases, this  restriction is not important - except in very specific instances, pure  computational activities will run faster using all threads.  But in some cases,  we may want to keep the primary thread free of blocking tasks.  For example, a  GUI running on the primary thread will become unresponsive if a computational  task hits.  For another, parallel computations with very nonuniform processing times can benefit from sacrificing the primary thread to manage the loads on the remaining ones.</p><p>ThreadPools is a simple package that allows background-only Task assignment for  cases where this makes sense.  (As Julia matures, it is hoped this package is  made obsolete.)  The standard <code>foreach</code>,  <code>map</code>, and <code>@threads</code> functions are  mimicked, adding a <code>bg</code> prefix to each to denote background operation:  <a href="#ThreadPools.bgforeach-Tuple{Any,Any}"><code>bgforeach</code></a>, <a href="#ThreadPools.bgmap-Tuple{Any,Any}"><code>bgmap</code></a>, <a href="#ThreadPools.@bgthreads"><code>@bgthreads</code></a>.  Code that runs  with one of  those Base functions should run just fine with the <code>bg</code> prepended,  but adding multithreading for free in the <code>foreach</code> and <code>map</code> cases, and in  all cases keeping the primary thread free of blocking Tasks.</p><h2 id="Usage-1"><a class="docs-heading-anchor" href="#Usage-1">Usage</a><a class="docs-heading-anchor-permalink" href="#Usage-1" title="Permalink"></a></h2><p>Each of the simple API functions can be used like the <code>Base</code> versions of the  same function, with a <code>bg</code> prepended to the function: </p><pre><code class="language-julia">julia&gt; bgforeach([1,2,3]) do x
         println(&quot;\$(x+1) \$(Threads.threadid())&quot;)
       end
3 3
4 4
2 2

julia&gt; bgmap([1,2,3]) do x
         println(&quot;\$x \$(Threads.threadid())&quot;)
         x^2
       end
2 3
3 4
1 2
3-element Array{Int64,1}:
 1
 4
 9

julia&gt; @bgthreads for x in 1:3
         println(&quot;\$x \$(Threads.threadid())&quot;)
       end
2 3
3 4
1 2</code></pre><p>For an example of a more complex load-management scenario, see  <code>examples/stackdemo.jl</code>.</p><h2 id="Demonstrations-1"><a class="docs-heading-anchor" href="#Demonstrations-1">Demonstrations</a><a class="docs-heading-anchor-permalink" href="#Demonstrations-1" title="Permalink"></a></h2><p>There are a couple of demonstrations in the <code>examples</code> directory.  <code>demo.jl</code>  shows how jobs are distributed across threads in both the <code>@threads</code> and  <code>@bgthreads</code> cases for various workload distributions.  Running these demos  is fairly simple (results below on 4 threads):</p><pre><code class="language-none">julia&gt; include(&quot;examples/demo.jl&quot;)
Main.Demo

julia&gt; Demo.run_with_outliers()


@bgthreads, Active Job Per Thread on 200ms Intervals

   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0
   0   6  14  25  29  31  31  40  49  52  62  68  73  83  89   0 100 105 109 109 109 109 109 109 132 137 141 147   0   0   0
   0   8  15  20  30  33  33  33  50  57  63  66  66  84  90  94   0 104 108 112 116 121 123 127 131 134 134 134   0   0   0
   0   9  12  24  24  24  35  38   0  56  61  69   0  82  91  95  98  98  98 113 117 120 120 120 120 135 142 146   0   0   0


@threads, Active Job Per Thread on 200ms Intervals

   0   4   6   9  10  12  15  16  20  24  24  24  28  29  31  31  32  33  33  34  37   0   0   0   0   0
   0  43  46  50  52  54  56  60  62  65  66  66  68  70  73   0   0   0   0   0   0   0   0   0   0   0
   0  79  82  84  87  90  92  94  96  98  98  98  98 100 101 104 106 108 109 109 109 109 109 110 112   0
   0 117 119 120 120 120 120 121 124 127 131 133 134 134 134 137 141 143 146 149   0   0   0   0   0   0

Speed increase using all threads (ideal 33.3%): 14.4%</code></pre><p>These demos generate numbered jobs with a randomized work distribution that can  be varied.  There are normal, uniform,  and uniform with 10% outliers of 10x  distributions.  The activity graphs in these demos present time-sliced shapshots  of the thread activities, showing which job number was active in that time  slice.</p><p>The available demos are:</p><ul><li><code>Demo.run_with_uniform()</code></li><li><code>Demo.run_with_variation()</code></li><li><code>Demo.run_with_outliers()</code></li></ul><p>There is also a more complex demo at <code>examples/stackdemo.jl</code>.  Here, the  workload is heirarchal - each jobs produces a result and possibly more jobs.  The primary thread in this case is used purely more managing the job stack.</p><h2 id="Simple-API-1"><a class="docs-heading-anchor" href="#Simple-API-1">Simple API</a><a class="docs-heading-anchor-permalink" href="#Simple-API-1" title="Permalink"></a></h2><p>Each function of the simple API tries to mimic an existing function in <code>Base</code>  or <code>Base.Threads</code> to keep any code rework to a minimum.</p><ul><li><a href="#ThreadPools.bgforeach-Tuple{Any,Any}"><code>bgforeach(fn, itr)</code></a></li><li><a href="#ThreadPools.bgmap-Tuple{Any,Any}"><code>bgmap(fn, itr)</code></a></li><li><a href="#ThreadPools.@bgthreads"><code>@bgthreads</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="ThreadPools.bgforeach-Tuple{Any,Any}" href="#ThreadPools.bgforeach-Tuple{Any,Any}"><code>ThreadPools.bgforeach</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">bgforeach(fn, itrs...) -&gt; Nothing</code></pre><p>Mimics the  <a href="https://docs.julialang.org/en/v1/base/collections/#Base.foreach"><code>Base.foreach</code></a>  function, but spawns each iteration to a background thread.  Falls back to  <a href="https://docs.julialang.org/en/v1/base/collections/#Base.foreach"><code>Base.foreach</code></a>  when nthreads() == 1.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; bgforeach([1,2,3]) do x
    println(&quot;$(x+1) $(Threads.threadid())&quot;)
  end
3 3
4 4
2 2</code></pre><p>Note that the execution order across the threads is not guaranteed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tro3/ThreadPool.jl/blob/1c9c501c0d8339e207559eee43a39af0734fd290/src/functions.jl#L1-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ThreadPools.bgmap-Tuple{Any,Any}" href="#ThreadPools.bgmap-Tuple{Any,Any}"><code>ThreadPools.bgmap</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">bgmap(fn, itrs...) -&gt; collection</code></pre><p>Mimics the  <a href="https://docs.julialang.org/en/v1/base/collections/#Base.map"><code>Base.map</code></a>  function, but spawns each case to a background thread.  Falls back to  <code>Base.map</code> when nthreads() == 1.</p><p>Note that the collection(s) supplied must be of equal and finite length.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; bgmap([1,2,3]) do x
         println(&quot;$x $(Threads.threadid())&quot;)
         x^2
       end
2 3
3 4
1 2
3-element Array{Int64,1}:
 1
 4
 9</code></pre><p>Note that while the thread execution order is not guaranteed, the final  result will maintain the proper sequence.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tro3/ThreadPool.jl/blob/1c9c501c0d8339e207559eee43a39af0734fd290/src/functions.jl#L54-L80">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ThreadPools.@bgthreads" href="#ThreadPools.@bgthreads"><code>ThreadPools.@bgthreads</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@bgthreads</code></pre><p>A macro to parallelize a for-loop to run with multiple threads. </p><p><code>@bgthreads</code> mimics the  <a href="https://docs.julialang.org/en/v1/base/multi-threading/#Base.Threads.@threads"><code>Threads.@threads</code></a>  macro, but keeps the activity off of the primary thread.  Will fall back  gracefully to <code>Base.foreach</code> behavior when nthreads == 1.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; @bgthreads for x in 1:3
        println(&quot;$x $(Threads.threadid())&quot;)
       end
2 3
3 4
1 2</code></pre><p>Note that the execution order across the threads is not guaranteed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tro3/ThreadPool.jl/blob/1c9c501c0d8339e207559eee43a39af0734fd290/src/functions.jl#L125-L145">source</a></section></article><h1 id="ThreadPool-API-1"><a class="docs-heading-anchor" href="#ThreadPool-API-1">ThreadPool API</a><a class="docs-heading-anchor-permalink" href="#ThreadPool-API-1" title="Permalink"></a></h1><p>The <a href="#ThreadPools.ThreadPool"><code>ThreadPool</code></a> mimics the <code>Channel{Task}</code> API,  where <code>put!</code>ting a <code>Task</code> causes it to be executed, and <code>take!</code> returns the  completed <code>Task</code>.  The <code>ThreadPool</code> is iterable over the completed <code>Task</code>s in the same way a <code>Channel</code> would be.</p><ul><li><a href="#ThreadPools.ThreadPool"><code>ThreadPools.ThreadPool</code></a></li><li><a href="#Base.put!(pool::ThreadPools.ThreadPool, t::Task)"><code>Base.put!(pool::ThreadPool, t::Task)</code></a></li><li><a href="#Base.put!(pool::ThreadPools.ThreadPool, fn::Function, args...)"><code>Base.put!(pool::ThreadPool, fn::Function, args...)</code></a></li><li><a href="#Base.take!(pool::ThreadPools.ThreadPool, ind::Integer)"><code>Base.take!(pool::ThreadPool, ind::Integer)</code></a></li><li><a href="#Base.close(pool::ThreadPools.ThreadPool)"><code>Base.close(pool::ThreadPool)</code></a></li><li><a href="#ThreadPools.isactive-Tuple{ThreadPool}"><code>ThreadPools.isactive(pool::ThreadPool)</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="ThreadPools.ThreadPool" href="#ThreadPools.ThreadPool"><code>ThreadPools.ThreadPool</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ThreadPool(allow_primary=false)</code></pre><p>The main ThreadPool object. Its API mimics that of a <code>Channel{Task}</code>, but each submitted task is executed on a different thread.  If <code>allow_primary</code> is true,  the assigned thread might be the primary, which will interfere with future  thread management for the duration of any heavy-computational (blocking) processes.  If it is false, all assigned threads will be off of the primary. Each thread will only be allowed one Task at a time, but each thread will  backfill with the next queued Task immediately on completion of the previous, without regard to how bust the other threads may be.  </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tro3/ThreadPool.jl/blob/1c9c501c0d8339e207559eee43a39af0734fd290/src/pool.jl#L4-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.put!-Tuple{ThreadPool,Task}" href="#Base.put!-Tuple{ThreadPool,Task}"><code>Base.put!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Base.put!(pool::ThreadPool, t::Task)</code></pre><p>Put the task <code>t</code> into the pool, blocking until the pool has an available thread.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tro3/ThreadPool.jl/blob/1c9c501c0d8339e207559eee43a39af0734fd290/src/pool.jl#L41-L46">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.put!-Tuple{ThreadPool,Function,Vararg{Any,N} where N}" href="#Base.put!-Tuple{ThreadPool,Function,Vararg{Any,N} where N}"><code>Base.put!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Base.put!(pool::ThreadPool, fn::Function, args...)
Base.put!(fn::Function, pool::ThreadPool, args...)</code></pre><p>Creates a task that runs <code>fn(args...)</code> and adds it to the pool, blocking  until the pool has an available thread.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tro3/ThreadPool.jl/blob/1c9c501c0d8339e207559eee43a39af0734fd290/src/pool.jl#L50-L56">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.take!-Tuple{ThreadPool}" href="#Base.take!-Tuple{ThreadPool}"><code>Base.take!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Base.take!(pool::ThreadPool) -&gt; Task</code></pre><p>Takes the next available completed task from the pool, blocking until a task is available.  </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tro3/ThreadPool.jl/blob/1c9c501c0d8339e207559eee43a39af0734fd290/src/pool.jl#L61-L66">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.close-Tuple{ThreadPool}" href="#Base.close-Tuple{ThreadPool}"><code>Base.close</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Base.close(pool::ThreadPool)</code></pre><p>Shuts down the pool, closing the internal thread handlers.  It is safe to issue this command after all Tasks have been submitted, regardless of the Task completion status. If issued while the pool is still active, it  will <code>yield</code> until all tasks have been completed. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tro3/ThreadPool.jl/blob/1c9c501c0d8339e207559eee43a39af0734fd290/src/pool.jl#L70-L77">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ThreadPools.isactive-Tuple{ThreadPool}" href="#ThreadPools.isactive-Tuple{ThreadPool}"><code>ThreadPools.isactive</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ThreadPools.isactive(pool::ThreadPool)</code></pre><p>Returns <code>true</code> if there are queued Tasks anywhere in the pool, either awaiting execution, executing, or waiting to be retrieved.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tro3/ThreadPool.jl/blob/1c9c501c0d8339e207559eee43a39af0734fd290/src/pool.jl#L99-L104">source</a></section></article></article></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Tuesday 14 January 2020 22:07">Tuesday 14 January 2020</span>. Using Julia version 1.3.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
