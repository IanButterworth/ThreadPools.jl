var documenterSearchIndex = {"docs":
[{"location":"#ThreadPools.jl-Documentation-1","page":"ThreadPools.jl Documentation","title":"ThreadPools.jl Documentation","text":"","category":"section"},{"location":"#","page":"ThreadPools.jl Documentation","title":"ThreadPools.jl Documentation","text":"Improved background Task management, keeping heavy Julia computations off the primary thread","category":"page"},{"location":"#","page":"ThreadPools.jl Documentation","title":"ThreadPools.jl Documentation","text":"A simple package that creates a few functions mimicked from Base (bgforeach, bgmap, and @bgthreads) that behave like the originals but generate spawned tasks  that stay purely on background threads.","category":"page"},{"location":"#Overview-1","page":"ThreadPools.jl Documentation","title":"Overview","text":"","category":"section"},{"location":"#","page":"ThreadPools.jl Documentation","title":"ThreadPools.jl Documentation","text":"As of v1.3.1, Julia does not have any built-in mechanisms for keeping  computational threads off of the primary thread.  For many use cases, this  restriction is not important - except in very specific instances, pure  computational activities will run faster using all threads.  But in some cases,  we may want to keep the primary thread free of blocking tasks.  For example, a  GUI running on the primary thread will become unresponsive if a computational  task hits.  For another, parallel computations with very nonuniform processing times can benefit from sacrificing the primary thread to manage the loads on the remaining ones.","category":"page"},{"location":"#","page":"ThreadPools.jl Documentation","title":"ThreadPools.jl Documentation","text":"ThreadPools is a simple package that allows background-only Task assignment for  cases where this makes sense.  (As Julia matures, it is hoped this package is  made obsolete.)  The standard foreach,  map, and @threads functions are  mimicked, adding a bg prefix to each to denote background operation:  bgforeach, bgmap, @bgthreads.  Code that runs  with one of  those Base functions should run just fine with the bg prepended,  but adding multithreading for free in the foreach and map cases, and in  all cases keeping the primary thread free of blocking Tasks.","category":"page"},{"location":"#Usage-1","page":"ThreadPools.jl Documentation","title":"Usage","text":"","category":"section"},{"location":"#","page":"ThreadPools.jl Documentation","title":"ThreadPools.jl Documentation","text":"Each of the simple API functions can be used like the Base versions of the  same function, with a bg prepended to the function: ","category":"page"},{"location":"#","page":"ThreadPools.jl Documentation","title":"ThreadPools.jl Documentation","text":"julia> bgforeach([1,2,3]) do x\r\n         println(\"\\$(x+1) \\$(Threads.threadid())\")\r\n       end\r\n3 3\r\n4 4\r\n2 2\r\n\r\njulia> bgmap([1,2,3]) do x\r\n         println(\"\\$x \\$(Threads.threadid())\")\r\n         x^2\r\n       end\r\n2 3\r\n3 4\r\n1 2\r\n3-element Array{Int64,1}:\r\n 1\r\n 4\r\n 9\r\n\r\njulia> @bgthreads for x in 1:3\r\n         println(\"\\$x \\$(Threads.threadid())\")\r\n       end\r\n2 3\r\n3 4\r\n1 2","category":"page"},{"location":"#","page":"ThreadPools.jl Documentation","title":"ThreadPools.jl Documentation","text":"For an example of a more complex load-management scenario, see  examples/stackdemo.jl.","category":"page"},{"location":"#Demonstrations-1","page":"ThreadPools.jl Documentation","title":"Demonstrations","text":"","category":"section"},{"location":"#","page":"ThreadPools.jl Documentation","title":"ThreadPools.jl Documentation","text":"There are a couple of demonstrations in the examples directory.  demo.jl  shows how jobs are distributed across threads in both the @threads and  @bgthreads cases for various workload distributions.  Running these demos  is fairly simple (results below on 4 threads):","category":"page"},{"location":"#","page":"ThreadPools.jl Documentation","title":"ThreadPools.jl Documentation","text":"julia> include(\"examples/demo.jl\")\r\nMain.Demo\r\n\r\njulia> Demo.run_with_outliers()\r\n\r\n\r\n@bgthreads, Active Job Per Thread on 200ms Intervals\r\n\r\n   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0\r\n   0   6  14  25  29  31  31  40  49  52  62  68  73  83  89   0 100 105 109 109 109 109 109 109 132 137 141 147   0   0   0\r\n   0   8  15  20  30  33  33  33  50  57  63  66  66  84  90  94   0 104 108 112 116 121 123 127 131 134 134 134   0   0   0\r\n   0   9  12  24  24  24  35  38   0  56  61  69   0  82  91  95  98  98  98 113 117 120 120 120 120 135 142 146   0   0   0\r\n\r\n\r\n@threads, Active Job Per Thread on 200ms Intervals\r\n\r\n   0   4   6   9  10  12  15  16  20  24  24  24  28  29  31  31  32  33  33  34  37   0   0   0   0   0\r\n   0  43  46  50  52  54  56  60  62  65  66  66  68  70  73   0   0   0   0   0   0   0   0   0   0   0\r\n   0  79  82  84  87  90  92  94  96  98  98  98  98 100 101 104 106 108 109 109 109 109 109 110 112   0\r\n   0 117 119 120 120 120 120 121 124 127 131 133 134 134 134 137 141 143 146 149   0   0   0   0   0   0\r\n\r\nSpeed increase using all threads (ideal 33.3%): 14.4%","category":"page"},{"location":"#","page":"ThreadPools.jl Documentation","title":"ThreadPools.jl Documentation","text":"These demos generate numbered jobs with a randomized work distribution that can  be varied.  There are normal, uniform,  and uniform with 10% outliers of 10x  distributions.  The activity graphs in these demos present time-sliced shapshots  of the thread activities, showing which job number was active in that time  slice.","category":"page"},{"location":"#","page":"ThreadPools.jl Documentation","title":"ThreadPools.jl Documentation","text":"The available demos are:","category":"page"},{"location":"#","page":"ThreadPools.jl Documentation","title":"ThreadPools.jl Documentation","text":"Demo.run_with_uniform()\nDemo.run_with_variation()\nDemo.run_with_outliers()","category":"page"},{"location":"#","page":"ThreadPools.jl Documentation","title":"ThreadPools.jl Documentation","text":"There is also a more complex demo at examples/stackdemo.jl.  Here, the  workload is heirarchal - each jobs produces a result and possibly more jobs.  The primary thread in this case is used purely more managing the job stack.","category":"page"},{"location":"#Simple-API-1","page":"ThreadPools.jl Documentation","title":"Simple API","text":"","category":"section"},{"location":"#","page":"ThreadPools.jl Documentation","title":"ThreadPools.jl Documentation","text":"Each function of the simple API tries to mimic an existing function in Base  or Base.Threads to keep any code rework to a minimum.","category":"page"},{"location":"#","page":"ThreadPools.jl Documentation","title":"ThreadPools.jl Documentation","text":"bgforeach(fn, itr)\nbgmap(fn, itr)\n@bgthreads","category":"page"},{"location":"#","page":"ThreadPools.jl Documentation","title":"ThreadPools.jl Documentation","text":"bgforeach(fn, itr)\r\nbgmap(fn, itr)\r\n@bgthreads","category":"page"},{"location":"#ThreadPools.bgforeach-Tuple{Any,Any}","page":"ThreadPools.jl Documentation","title":"ThreadPools.bgforeach","text":"bgforeach(fn, itrs...) -> Nothing\n\nMimics the  Base.foreach  function, but spawns each iteration to a background thread.  Falls back to  Base.foreach  when nthreads() == 1.\n\nExample\n\njulia> bgforeach([1,2,3]) do x\n    println(\"$(x+1) $(Threads.threadid())\")\n  end\n3 3\n4 4\n2 2\n\nNote that the execution order across the threads is not guaranteed.\n\n\n\n\n\n","category":"method"},{"location":"#ThreadPools.bgmap-Tuple{Any,Any}","page":"ThreadPools.jl Documentation","title":"ThreadPools.bgmap","text":"bgmap(fn, itrs...) -> collection\n\nMimics the  Base.map  function, but spawns each case to a background thread.  Falls back to  Base.map when nthreads() == 1.\n\nNote that the collection(s) supplied must be of equal and finite length.\n\nExample\n\njulia> bgmap([1,2,3]) do x\n         println(\"$x $(Threads.threadid())\")\n         x^2\n       end\n2 3\n3 4\n1 2\n3-element Array{Int64,1}:\n 1\n 4\n 9\n\nNote that while the thread execution order is not guaranteed, the final  result will maintain the proper sequence.\n\n\n\n\n\n","category":"method"},{"location":"#ThreadPools.@bgthreads","page":"ThreadPools.jl Documentation","title":"ThreadPools.@bgthreads","text":"@bgthreads\n\nA macro to parallelize a for-loop to run with multiple threads. \n\n@bgthreads mimics the  Threads.@threads  macro, but keeps the activity off of the primary thread.  Will fall back  gracefully to Base.foreach behavior when nthreads == 1.\n\nExample\n\njulia> @bgthreads for x in 1:3\n        println(\"$x $(Threads.threadid())\")\n       end\n2 3\n3 4\n1 2\n\nNote that the execution order across the threads is not guaranteed.\n\n\n\n\n\n","category":"macro"},{"location":"#ThreadPool-API-1","page":"ThreadPools.jl Documentation","title":"ThreadPool API","text":"","category":"section"},{"location":"#","page":"ThreadPools.jl Documentation","title":"ThreadPools.jl Documentation","text":"The ThreadPool mimics the Channel{Task} API,  where put!ting a Task causes it to be executed, and take! returns the  completed Task.  The ThreadPool is iterable over the completed Tasks in the same way a Channel would be.","category":"page"},{"location":"#","page":"ThreadPools.jl Documentation","title":"ThreadPools.jl Documentation","text":"ThreadPools.ThreadPool\nBase.put!(pool::ThreadPool, t::Task)\nBase.put!(pool::ThreadPool, fn::Function, args...)\nBase.take!(pool::ThreadPool, ind::Integer)\nBase.close(pool::ThreadPool)\nThreadPools.isactive(pool::ThreadPool)","category":"page"},{"location":"#","page":"ThreadPools.jl Documentation","title":"ThreadPools.jl Documentation","text":"ThreadPools.ThreadPool\r\nBase.put!(pool::ThreadPools.ThreadPool, t::Task)\r\nBase.put!(pool::ThreadPools.ThreadPool, fn::Function, args...)\r\nBase.take!(pool::ThreadPools.ThreadPool)\r\nBase.close(pool::ThreadPools.ThreadPool)\r\nThreadPools.isactive(pool::ThreadPool)","category":"page"},{"location":"#ThreadPools.ThreadPool","page":"ThreadPools.jl Documentation","title":"ThreadPools.ThreadPool","text":"ThreadPool(allow_primary=false)\n\nThe main ThreadPool object. Its API mimics that of a Channel{Task}, but each submitted task is executed on a different thread.  If allow_primary is true,  the assigned thread might be the primary, which will interfere with future  thread management for the duration of any heavy-computational (blocking) processes.  If it is false, all assigned threads will be off of the primary. Each thread will only be allowed one Task at a time, but each thread will  backfill with the next queued Task immediately on completion of the previous, without regard to how bust the other threads may be.  \n\n\n\n\n\n","category":"type"},{"location":"#Base.put!-Tuple{ThreadPool,Task}","page":"ThreadPools.jl Documentation","title":"Base.put!","text":"Base.put!(pool::ThreadPool, t::Task)\n\nPut the task t into the pool, blocking until the pool has an available thread.\n\n\n\n\n\n","category":"method"},{"location":"#Base.put!-Tuple{ThreadPool,Function,Vararg{Any,N} where N}","page":"ThreadPools.jl Documentation","title":"Base.put!","text":"Base.put!(pool::ThreadPool, fn::Function, args...)\nBase.put!(fn::Function, pool::ThreadPool, args...)\n\nCreates a task that runs fn(args...) and adds it to the pool, blocking  until the pool has an available thread.\n\n\n\n\n\n","category":"method"},{"location":"#Base.take!-Tuple{ThreadPool}","page":"ThreadPools.jl Documentation","title":"Base.take!","text":"Base.take!(pool::ThreadPool) -> Task\n\nTakes the next available completed task from the pool, blocking until a task is available.  \n\n\n\n\n\n","category":"method"},{"location":"#Base.close-Tuple{ThreadPool}","page":"ThreadPools.jl Documentation","title":"Base.close","text":"Base.close(pool::ThreadPool)\n\nShuts down the pool, closing the internal thread handlers.  It is safe to issue this command after all Tasks have been submitted, regardless of the Task completion status. If issued while the pool is still active, it  will yield until all tasks have been completed. \n\n\n\n\n\n","category":"method"},{"location":"#ThreadPools.isactive-Tuple{ThreadPool}","page":"ThreadPools.jl Documentation","title":"ThreadPools.isactive","text":"ThreadPools.isactive(pool::ThreadPool)\n\nReturns true if there are queued Tasks anywhere in the pool, either awaiting execution, executing, or waiting to be retrieved.\n\n\n\n\n\n","category":"method"}]
}
